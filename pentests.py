#!/usr/bin/env python
import argparse
import sys
import networkx as nx
import re
import numpy as np
import itertools

_s = re.compile('\s+')
_p = re.compile('(\d+)\s+(\d+)')

def lsqp(atoms):
    com = atoms.mean(axis=0)
    #u, d, v = np.linalg.svd(atoms-com)

    axes = np.zeros((len(atoms), 3))
    for i in range(len(atoms)):
        p1 = atoms[i]
        if i == len(atoms)-1:
            p2 = atoms[0]
        else:
            p2 = atoms[i+1]
        a = np.cross(p1, p2)
        axes += a
    u, d, v = np.linalg.svd(axes)
    i = 0
    d = -np.dot(v[i], com)
    n = -np.array((v[i,0], v[i,1], d))/v[i,2]
    return v[i], com, n

def intriangle(triangle, axis, u, p):
    # http://www.softsurfer.com/Archive/algorithm_0105/algorithm_0105.htm
    p1, p2, p3 = triangle
    w0 = p - p1
    a = -np.dot(axis, w0)
    b = np.dot(axis, u)
    if (abs(b) < 0.01): return False

    r = a / b
    if r < 0.0: return False
    if r > 1.0: return False

    I = p + u * r

    u = p2 - p1
    v = p3 - p1
    uu = np.dot(u, u)
    uv = np.dot(u, v)
    vv = np.dot(v, v)
    w = I - p1
    wu = np.dot(w, u)
    wv = np.dot(w, v)
    D = uv * uv - uu * vv

    s = (uv * wv - vv * wu)/D
    if (s < 0 or s > 1): return False
    t = (uv * wu - uu * wv)/D
    if (t < 0 or (s+t) > 1): return False
    return True

def build_topology(psffile):
    g = nx.Graph()
    flag = 0

    for line in open(psffile).readlines():
        if flag == 0 and line.strip().endswith('NATOM'):
            flag = 1
            continue
        if flag == 0 and line.strip().endswith('bonds'):
            flag = 2
            continue
        if flag == 1 and not line.strip(): flag = 0
        if flag == 2 and not line.strip(): break

        if flag == 1:
            num, segid, resid, resname, name = _s.split(line)[1:6]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            g.add_node(int(num), {'segid': segid, 'resname': resname, 'name': name, 'resid': resid})

        if flag == 2:
            for pair in _p.findall(line):
                num1, num2 = map(int, pair)
                if g.has_node(num1) and g.has_node(num2): g.add_edge(num1, num2)
    return g

def build_atomtable(psf, crdfile):
    crds = {}
    flag = 0
    for line in open(crdfile).readlines():
        entries = _s.split(line)
        if flag == 0 and entries[0] != '*':
            flag = 1
            continue
        if flag == 1 and not line.strip(): break

        if flag == 1:
            num, resid, resname, name, x, y, z, segid = _s.split(line.strip())[:8]
            if resname.startswith('TIP3'): continue
            if name.startswith('H'): continue
            if psf.node[int(num)]['name'] != name: raise AtomMismatch("%d %s != %d %s" % (int(num), psf.node[int(num)]['name'], int(num), name))
            crds[int(num)] = np.array((float(x), float(y), float(z)))
    return crds

class AtomMismatch(Exception):
    pass

def check_ring_penetration(psf, crd, verbose=0):
    # ring penetration test
    # 1. find rings
    # 2. build least square plane
    # 3. project atoms ring constituent atoms onto the plane and build convex
    # 4. find two bonded atoms that are at the opposite side of the plane
    # 5. determine the point of intersection is enclosed in the ring
    #
    molecules = nx.connected_component_subgraphs(psf)
    allatoms = np.array([crd[num] for num in psf.nodes()])
    atoms_map = np.array([num for num in psf.nodes()])
    pen_pairs = []
    pen_cycles = []
    flag = False

    for m in molecules:
        cycles = nx.cycle_basis(m)
        if not cycles: continue
        for cycle in cycles:
            atoms = np.array([crd[num] for num in cycle])
            if verbose:
                num = cycle[0]
                print 'found ring:', psf.node[num]['segid'], psf.node[num]['resid'], psf.node[num]['resname']

            # build least square fit plane
            axis, com, n = lsqp(atoms)

            # project atoms to the least square fit plane
            for i,atom in enumerate(atoms):
                w = np.dot(axis, atom-com)*axis + com
                atoms[i] = com + (atom - w)

            maxd = np.max(np.sqrt(np.sum(np.square(atoms - com), axis=1)))

            d = np.square(np.sum((allatoms-com), axis=1))
            nums = np.argwhere(d < 3)
            nums = np.reshape(nums, len(nums))

            # find two bonded atoms that are at the opposite side of the plane
            for num in nums:
                num1 = atoms_map[num]

                for num2 in psf[num1]:
                    if num1 in cycle or num2 in cycle: continue
                    crd1 = crd[num1]
                    crd2 = crd[num2]

                    v1 = np.dot(crd1 - com, axis)
                    v2 = np.dot(crd2 - com, axis)
                    if v1 * v2 > 0: continue

                    # point of intersection of the least square fit plane
                    s = -np.dot(axis, crd1-com)/np.dot(axis, crd2-crd1)
                    p = crd1 + s*(crd2-crd1)

                    d = np.sqrt(np.sum(np.square(p-com)))
                    if d > maxd: continue
                    if verbose:
                        print 'found potentially pentrarting bond:', psf.node[num1]['segid'], psf.node[num1]['resid'], psf.node[num1]['resname'], psf.node[num1]['name'], psf.node[num2]['name']

                    d = 0
                    for i in range(0, len(atoms)):
                        p1 = atoms[i] - p
                        try: p2 = atoms[i+1] - p
                        except: p2 = atoms[0] - p
                        d += np.arccos(np.dot(p1, p2)/np.linalg.norm(p1)/np.linalg.norm(p2))

                    wn = d/2/np.pi
                    if wn > 0.9 and wn < 1.1:
                        # we have a case
                        pen_pairs.append((num1, num2))
                        pen_cycles.append(cycle)
                        flag = True
                        break

                if flag: break

    return pen_pairs, pen_cycles

def find_alpha(atoms, tetrahedra, conv, verbose=0):
    maxs = np.ceil(np.max(atoms, axis=0))
    mins = np.floor(np.min(atoms, axis=0))
    #ah = np.sum((maxs - mins)**2)
    #al = 0
    ah = 10
    al = 6
    am = 0
    for i in range(17):
        am = (al+ah)/2
        if verbose: print 'testing alpha: ', am, ah, al
        if check_alpha_shape(atoms, tetrahedra, conv, am): ah = am
        else: al = am
        if (ah - al)/ah < 0.5: break
    return ah*1.1

def check_alpha_shape(atoms, tetrahedra, conv, alpha):
    faces = alpha_shape(atoms, tetrahedra, conv, alpha)
    g = nx.Graph()
    for n,atom in enumerate(atoms):
        g.add_node(n)

    for face in faces:
        for n1, n2 in itertools.combinations(face, 2):
            g.add_edge(n1, n2)
    return len(nx.connected_components(g)) == 1

def alpha_shape(atoms, tetrahedra, conv, alpha):
    squared_alpha = np.sqrt(alpha)
    faces = []
    interiors = []
    for t in tetrahedra.vertices:
        r, c = radius_circumsphere(atoms, t)
        is_empty = is_empty_sphere(atoms, r, c)
        for face in itertools.combinations(t, 3):
            if r < squared_alpha and is_empty:
                if set(face) in faces:
                    interiors.append(set(face))
                    continue
                faces.append(set(face))
            else:
                rr, cc = radius_circle(atoms, face)
                is_empty_d = is_empty_sphere(atoms, rr, cc)
                if rr < squared_alpha and is_empty_d:
                    faces.append(set(face))

    faces = [tuple(face) for face in faces if face not in interiors]
    return faces

def radius_circumsphere(atoms, v):
    o = atoms[v[0]]
    a = atoms[v[1]] - o
    b = atoms[v[2]] - o
    c = atoms[v[3]] - o
    vv = np.dot(a, np.cross(b, c))
    nn = np.dot(a, a) * np.cross(b, c) + np.dot(b, b) * np.cross(c, a) + np.dot(c, c) * np.cross(a, b)
    r = np.linalg.norm( nn ) / ( 2 * vv )
    c = nn / ( 2 * vv )
    return r, c

def radius_circle(atoms, v):
    o = atoms[v[0]]
    a = atoms[v[1]] - o
    b = atoms[v[2]] - o
    aa = np.linalg.norm(a)
    bb = np.linalg.norm(b)
    ab = np.cross(a, b)
    r = aa * bb *np.linalg.norm(a-b) / 2 / np.linalg.norm(ab)
    c = np.cross(aa**2 * b - bb**2 * a, ab) / 2 / np.linalg.norm(ab)**2 + o
    return r, c

def is_empty_sphere(atoms, r, c):
    d = np.sqrt(np.sum(np.square(atoms - c), axis=1))
    #print d
    return not True in (d < r-0.1)

def find_alpha_shape(atoms, verbose=0):
    from pyhull.delaunay import DelaunayTri
    tetrahedra = DelaunayTri(atoms)

    from pyhull.convex_hull import ConvexHull
    conv = nx.Graph()
    for t in ConvexHull(atoms).vertices:
        for e in itertools.combinations(t, 2):
            conv.add_edge(e[0], e[1])

    #alpha = find_alpha(atoms, tetrahedra, conv, verbose)
    alpha = 11.1
    if verbose:
        print 'alpha: ', alpha
    faces = alpha_shape(atoms, tetrahedra, conv, alpha)
    return faces

def check_protein_penetration(psf, crds, verbose=0, output=0):
    # protein penetration test
    # 1. build alpha-shape of the protein based on the CA and CB atoms within 6A
    # 2. find two atoms that placed opposite side of the hull
    #

    prot_atoms = np.array([crds[num] for num in psf.nodes() if psf.node[num]['name'] in ['CA', 'CB']])
    prot_segids = set([psf.node[num]['segid'] for num in psf.nodes() if psf.node[num]['name'] == 'CA'])
    pen_pairs = []
    if len(prot_atoms) == 0: return pen_pairs

    faces = find_alpha_shape(prot_atoms, verbose)

    if output:
        g = nx.Graph()
        for n,a in enumerate(prot_atoms):
            g.add_node(n)

        for face in faces:
            for e in itertools.combinations(face, 2):
                g.add_edge(e[0], e[1])

        fp = open('junk.pdb', 'w')
        for node in g.nodes():
            x, y, z = prot_atoms[node]
            fp.write("HETATM%5d  %-3s %3s  %4d    %8.3f%8.3f%8.3f  0.00  0.00      \n" % (node, 'C', 'DUM', node, x, y, z))

        for edge in g.edges():
            fp.write("CONECT%5d%5d\n" % edge)

    flag = False
    facets_crds = [np.array((prot_atoms[face[0]], prot_atoms[face[1]], prot_atoms[face[2]])) for face in faces]
    facets_crds = np.array(facets_crds)
    dist = lambda x,y: np.sqrt(np.sum(np.square(x - y)))

    # find atoms potentially protruding the alpha-surface of the protein
    xmax, xmin = np.max(prot_atoms[:,0]), np.min(prot_atoms[:,0])
    ymax, ymin = np.max(prot_atoms[:,1]), np.min(prot_atoms[:,1])
    visited = []
    for node in psf.nodes():
        if psf.node[node]['segid'] in prot_segids: continue
        if node in visited: continue
        crd = crds[node]
        if ((crd[0] > (xmax+3) or crd[0] < (xmin-3)) and
            (crd[1] > (ymax+3) or crd[1] < (ymin-3))): continue
        if np.min(np.sum(np.square(facets_crds[:,0]-crd), axis=1)) > 25: continue

        # closest facet
        d = np.sum(np.square((np.sum(facets_crds, axis=1)/3) - crd), axis=1)
        if np.min(d) > 3: continue
        close_facets = np.argwhere(d < 3)
        if len(close_facets) == 0: continue
        close_facets = np.reshape(close_facets, (len(close_facets)))

        num1 = node
        u = []
        crd1 = np.array(crds[num1])
        for num2 in psf[num1]:
            crd2 = np.array(crds[num2])
            u.append((num2, crd2-crd1))

        flag = False
        for i in close_facets:
            facet = faces[i]
            p1 = np.array(prot_atoms[facet[0]])
            p2 = np.array(prot_atoms[facet[1]])
            p3 = np.array(prot_atoms[facet[2]])
            triangle = np.array((p1, p2, p3))
            axis = np.cross(p2-p1, p3-p1)

            for num2, r in u:
                if not intriangle(triangle, axis, r, crd1): continue
                else:
                    # we have a case
                    pen_pairs.append((num1, num2))
                    visited.append(num1)
                    visited.append(num2)
                    flag = True
                    break
            if flag: break

    return pen_pairs

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('psf', metavar='psffile', help='PSF file')
    parser.add_argument('crd', metavar='crdfile', help='CRD file')
    parser.add_argument('-v', dest='verbose', action='store_true')
    parser.add_argument('-o', dest='output', help='Visualize alpha shape', default=None)
    args = parser.parse_args()

    # build connectivity of atoms
    psf = build_topology(args.psf)
    crd = build_atomtable(psf, args.crd)

    # sanity check
    if len(psf.nodes()) != len(crd): raise AtomMismatch('Number of atom does not match')

    print '%lipid ring penetration'
    pairs, rings = check_ring_penetration(psf, crd, verbose=args.verbose)
    if pairs:
        #print 'found a ring penetration:'
        for cycle in rings:
            print '- %s %s %s %s' % (psf.node[cycle[0]]['segid'], psf.node[cycle[0]]['resid'], psf.node[cycle[0]]['resname'], ' '.join([psf.node[num]['name'] for num in cycle]))

    print '%protein surface penetration'
    pairs = check_protein_penetration(psf, crd, verbose=args.verbose, output=args.output)
    if pairs:
        #print 'found a protein penetration:'
        for pair in pairs:
            print '- %s %s %s %s %s' % (psf.node[pair[0]]['segid'], psf.node[pair[0]]['resid'], psf.node[pair[0]]['resname'], psf.node[pair[0]]['name'], psf.node[pair[1]]['name'])


if __name__ == '__main__':
    main()
